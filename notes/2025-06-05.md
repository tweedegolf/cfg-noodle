# Open Questions
- What are the expected Flash error modes? Are only single bits/bytes going to be "bad" or entire pages?
- What should happen when the latest list is corrupted (between write validation and the next read)? Should we try to obtain as much of the latest config data as possible and fall back to one of the "backups" for missing/corrupted nodes or use _only_ the latest complete backup?

# Result of our discussion today (2025-06-05)
- Treat writes as atomic: if no `write_confirm` block is found for the counter value, simply ignore it
- Have a specific number of retries (e.g. always 3 or a parameter) where we write to flash and validate the data by reading it back. Only return an error if it does not succeed after that.
- Keep a specific number of entries in the flash as a "backup" in case the list is corrupted between verification and the next read

# Implementation
## Writing to flash
- Write a `start` block with the counter value to flash
- Write all nodes in the list to flash and read the data back to validate correctness
- If validation successful: write a `write_confirm` block that includes the counter and the number of nodes written
- If validation not successful: retry (until retry limit)

## Reading from Flash
- Iterate over the list, only searching `write_confirm` blocks.
- _Optional:_ If no `write_confirm` is found, treat as an empty flash and pop all remaining nodes off the queue (if any).
- If a `write_confirm` block is found:
  - Store its counter value
  - Check if the number of nodes that _should_ be present for this write match the actual number of nodes obtained from the queue. If not, at least one node is corrupted. Then what? (see open question)
  - Continue searching for newer `write_confirm`s until the end of the queue
- Start iterating over the queue again and start deserializing after the `start` block with for this "latest confirmed counter".
  - Continue until the `write_confirm` block. Mark every the deserialized node as "ValidNoWriteNeeded".
- Traverse the list and mark every non-hydrated (i.e. `State::Initial`) node as "NonResident".

## Cleanup task (garbage collection)
- Since only new nodes are written to the queue but no old ones are `pop`ed as part of the read process, a garbage collector task has to run periodically to make sure we don't run out of flash space.
- We could either "cache" some information about the flash queue after initial reading (i.e. how many items should be removed from the queue at the next garbage collection run) or just do a full scan of the queue every time the garbage collection runs.
  - Since reading is quite fast and cleanup does not block the write task, obtaining the queue state by reading from flash should be alright.
- When should it run:
  - periodically (e.g. every hour)
  - after initial hydration (e.g. 1 minute after bootup1)
  - after every write
  - BUT NOT when the list is written due to imminent shutdown (don't block shutdown just to erase a flash page!)
